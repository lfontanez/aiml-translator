<?php
/*
 * AIMLTranslate with Google Translate API
 * 
 * Author: Leamsi FontÃ¡nez - lfontanez@r1software.com
 * Copyright (c) 2017 R1 Software
 *
 * Requires google-translate-class.php
 */
class Translate
{
    var $googleTranslate;
    var $format;
    var $parser;
    var $uploads;
    var $downloads;
    var $save;
    
    public function __construct($apikey, $apiurl=false) {
        
        // Some default settings
        $this->format = 'xml';
        $this->parser = 'basic';
        $this->uploads = './uploads/';
        $this->downloads = './downloads/';
        $this->save = true;
        
		if (!$apiurl) $apiurl = 'https://www.googleapis.com/language/translate/v2';
		
		require_once('google-translate-class.php');
        $this->googleTranslate = new GoogleTranslate($apikey, $apiurl);
        
	}

	public function set_format($format) {
    	$this->format = $format;
    }
	
	public function get_format() {
		return $this->format;
	}  
	
	public function set_parser($parser) {
    	$this->parser = $parser;
    }
	
	public function get_parser() {
		return $this->parser;
	}  

	public function set_uploads($ul) {
    	$this->uploads = $ul;
    }
	
	public function get_uploads() {
		return $this->uploads;
	}  
	
	public function set_downloads($dl) {
    	$this->downloads = $dl;
    }
	
	public function get_downloads() {
		return $this->downloads;
	} 
	
	public function set_save($save) {
    	$this->save = $save;
    }
	
	public function get_save() {
		return $this->save;
	} 
	
    /*
     *
     * @param string $file AIML Filename
     * @param string $sl Source Language (2 letters)
     * @param string $tl Target Language (2 letters)
     * @param bool $save Save New AIML File
     */
    public function translateAIML ($file, $sl, $tl) {

        $rustart = getrusage();
    
        $original = array();
        $translated = array();
        $falsefails=0;
        
        $xml = file_get_contents($this->uploads . $file);
        $xml = $this->prepareXML($xml);

        //$this->debug($xml,false);
        //exit;
     
        switch ($this->parser) {
            case "xml":

                $xmlDoc = new DOMDocument();
                $xmlDoc->loadXML($xml);
                $xml2 = $xmlDoc->documentElement;
        
                $this->xmlParser($xml2, $sl, $tl, $original, $translated, $falsefails);               
                break;
                
            default:

                $this->basicParser($xml, $sl, $tl, $original, $translated, $falsefails);
        }

        $results = $this->compare($original, $translated, $falsefails);

        $xml = str_replace($original, $translated, $xml);
        $results['xml'] = $this->formatXML($xml);
        
        if ($this->save) {
            $file = explode('.aiml',$file);
            $new_file = $file[0]."-".$tl.".aiml";
            file_put_contents($this->downloads . $new_file, $xml);
            $results['filename'] = $new_file;
            $results['download_link'] = (isset($_SERVER['HTTPS']) ? "https" : "http") . "://{$_SERVER['HTTP_HOST']}{$_SERVER['REQUEST_URI']}{$this->downloads}$new_file";
        }

        $ru = getrusage();
        
        $bench  = "This process used " . $this->rutime($ru, $rustart, "utime") .
            " ms for its computations. ";
        $bench .=  "It spent " . $this->rutime($ru, $rustart, "stime") .
            " ms in system calls.";
            
        $results['stats']['benchmark'] = $bench;
        
        return $results;
    }

    private function basicParser ($xml, $sl, $tl, &$ori, &$tran, &$falsef) {
        
        $gt = $this->googleTranslate;
        $tags = array();
        preg_match_all('|<[^>]+>([^<>]+)<\/[^>]+>|', $xml, $tags, PREG_SET_ORDER);

        foreach ($tags as $tag) {
            
            $text = $this->clean($tag[1]);
            
            if ($text != '') {
                
                $ori[] = trim($tag[0]);
                
                $json = $gt->translateThis($sl, $tl, $text);
                $json = json_decode($json, true);
                $translation = $json['data']['translations'][0]['translatedText'];
                
                if ($translation == $text) $falsef++;
                
                if (strpos($tag[0], '<pattern>') !== false) {
                    $translation = $this->normalizePattern($translation);
                }    
                
                $tran[] = str_replace($text, $translation, trim($tag[0]));
                usleep(500);
            }
        }

    }
    private function xmlParser ($el, $sl, $tl, &$ori, &$tran, &$falsef) {
        
        $gt = $this->googleTranslate;
        
        foreach ($el->childNodes as $item) {

            if ($item->childNodes) {
                
                $this->xmlParser($item, $sl, $tl, $ori, $tran, $falsef);
                
            } elseif ($item->nodeType == 3 ) {
                
                $inner = $item->ownerDocument->saveXML( $item );
                $text = $this->clean( $item->textContent );

                if ($text != '') {

                    $outer = $this->get_outer_xml($item);
                    $ori[] = trim($outer);
                    
                    $json = $gt->translateThis($sl, $tl, $text);
                    $json = json_decode($json, true);
                    $translation = $json['data']['translations'][0]['translatedText'];
                    
                    if ($translation == $text) $falsef++;
                    
                    if (strpos($outer, $text) !== false) $replace = $text;
                        elseif (strpos($outer, $inner) !== false) $replace = $inner;
                            elseif (strpos($outer, $item->nodeValue) !== false) $replace = $item->nodeValue;

                    if (strpos($outer, '<pattern>') !== false) {
                        $translation = $this->normalizePattern($translation);
                    }
                    
                    $tran[] = str_replace($replace, $translation, trim($outer));
                    usleep(500);
                }
            }
        }
    }
    
    private function compare ($original, $translated, $falsefails) {
        
        $comparison = array();
        $success = array();
        $failed = array();
        
        foreach ($original as $k => $v){
            
            if ($v == $translated[$k]) $failed[] = array($v, $translated[$k]);
                else $success[] = array($v, $translated[$k]);
        }
        
        $comparison['stats']['parser'] = $this->parser;
        $comparison['stats']['failed'] = count($failed);
        $comparison['stats']['false_fails'] = $falsefails;
        $comparison['stats']['success'] = count($success);
        $total = count($original);
        $comparison['stats']['total'] = $total;
        $formatter = new NumberFormatter('en_US', NumberFormatter::PERCENT);
        $comparison['stats']['effectivity'] = $formatter->format( (count($success)+$falsefails) / $total);
        $comparison['failed'] = $failed;
        
        return $comparison;
    }
    
    private function prepareXML ($xml) {
        
        $xml = $this->clean($xml);

        return trim($xml);
    }
    
    private function formatXML ($xml) {
        
        $xml = str_replace("> <","><", $xml);
        $xml = preg_replace("/(<[a-zA-Z]+(>|.*?[^?]>))/", PHP_EOL."$1", $xml);
        $xml = str_replace("><" ,">".PHP_EOL."<", $xml);
        $xml = preg_replace ("/>\h+/", ">", $xml);
        $xml = preg_replace ("/\h+</", "<", $xml);
        
        return trim($xml);
    }
    
    private function clean ($str) {
        
        $str = trim(preg_replace('/\s+/', ' ', $str));
        $str = $this->cleanBR($str);
        $str = $this->cleanEOL($str);
        $str = $this->cleanP($str);

        return trim($str);
    }
    
    private function cleanBR ($str) {
        
        $str = str_replace('<br>', '', $str);
        $str = str_replace('<br />', '', $str);
        $str = str_replace('<br/>', '', $str);

        return $str;
    }
    
    private function cleanP ($str) {
        
        $str = preg_replace('/\s\s+/', "", $str);
        $str = str_replace(" . ", '. ', $str);
        $str = str_replace(" .", '.', $str);

        return $str;
    }
    
    private function cleanEOL ($str) {
        
        $str = trim(preg_replace('/\s+/', ' ', $str));
        $str = str_replace(PHP_EOL, '', $str);
        $str = str_replace("\n", "", $str);
        $str = str_replace("\r", "", $str);
        
        return $str;
    }
    
    /*
     * 
     * @param object $node DOM XML Object 
     *
     * This part was harder than I expected. had to use XMLReader
     * on the parent node, to be able to find and output XML of current node
     */
    private function get_outer_xml( $node ) { 

        $outerXML = $node->ownerDocument->saveXML( $node->parentNode );
        $innerXML = $node->ownerDocument->saveXML( $node );
        
        $reader = new XMLReader();
        $reader->xml($outerXML);
        
        while ($reader->read()) {
            if ($reader->readInnerXML() == $innerXML || $reader->readInnerXML() == $node->nodeValue || $reader->readString() == $node->textContent) {
                return $reader->readOuterXML();
            }
        }

    }
    
    public function debug ($var, $pre=true, $html=true) {
        
        if ($pre) echo '<pre>';
            else header('Content-type: application/xml');
        if (is_array($var)) {
            if ($html) array_walk_recursive($var, function(&$v) { $v = htmlspecialchars($v); });
            print_r($var);
        } elseif (is_object($var)) {
            var_dump($var);
        } else {
            echo $var;
        }
        
        if ($pre) echo '</pre>';
    }
    
    public function output ($var) {
        
        switch($this->format) {
            
            case 'xml':
                header('Content-type: application/xml');
                echo $var['xml'];
                exit();
                break;
                
            case 'download':
                header('Content-disposition: attachment; filename="'.$var['filename'].'"');
                header('Content-type: "text/xml"; charset="utf8"');
                readfile($var['download_link']);
                exit();
                break;
            
            default:
        
                $this->debug($var, true);
        }
    }
    public function rutime($ru, $rus, $index) {
        return ($ru["ru_$index.tv_sec"]*1000 + intval($ru["ru_$index.tv_usec"]/1000))
         -  ($rus["ru_$index.tv_sec"]*1000 + intval($rus["ru_$index.tv_usec"]/1000));
    }
    
    /**
     * Normalize an AIML Pattern
     *
     * @param string $str
     * @param array $options
     * @return string
     * 
     *  Modified by Leamsi FontÃ¡nez lfontanez@r1software.com - R1 Software
     * 
     * CREDITS:
     * 
     *  Original function was called url_slug
     * 
     *  Create a web friendly URL slug from a string.
     *
     *  @author Sean Murphy <sean@iamseanmurphy.com>
     *  @copyright Copyright 2012 Sean Murphy. All rights reserved.
     *  @license http://creativecommons.org/publicdomain/zero/1.0/
     */
    public function normalizePattern ($str, $options = array()) {
    	// Make sure string is in UTF-8 and strip invalid UTF-8 characters
    	$str = mb_convert_encoding((string)$str, 'UTF-8', mb_list_encodings());
    	
    	$defaults = array(
    		'uppercase' => true,
    		'transliterate' => true
    	);
    	
    	// Merge options
    	$options = array_merge($defaults, $options);
    	
    	$char_map = array(
    		// Latin
    		'Ã' => 'A', 'Ã' => 'A', 'Ã' => 'A', 'Ã' => 'A', 'Ã' => 'A', 'Ã' => 'A', 'Ã' => 'AE', 'Ã' => 'C', 
    		'Ã' => 'E', 'Ã' => 'E', 'Ã' => 'E', 'Ã' => 'E', 'Ã' => 'I', 'Ã' => 'I', 'Ã' => 'I', 'Ã' => 'I', 
    		'Ã' => 'D', 'Ã' => 'N', 'Ã' => 'O', 'Ã' => 'O', 'Ã' => 'O', 'Ã' => 'O', 'Ã' => 'O', 'Å' => 'O', 
    		'Ã' => 'O', 'Ã' => 'U', 'Ã' => 'U', 'Ã' => 'U', 'Ã' => 'U', 'Å°' => 'U', 'Ã' => 'Y', 'Ã' => 'TH', 
    		'Ã' => 'ss', 
    		'Ã ' => 'a', 'Ã¡' => 'a', 'Ã¢' => 'a', 'Ã£' => 'a', 'Ã¤' => 'a', 'Ã¥' => 'a', 'Ã¦' => 'ae', 'Ã§' => 'c', 
    		'Ã¨' => 'e', 'Ã©' => 'e', 'Ãª' => 'e', 'Ã«' => 'e', 'Ã¬' => 'i', 'Ã­' => 'i', 'Ã®' => 'i', 'Ã¯' => 'i', 
    		'Ã°' => 'd', 'Ã±' => 'n', 'Ã²' => 'o', 'Ã³' => 'o', 'Ã´' => 'o', 'Ãµ' => 'o', 'Ã¶' => 'o', 'Å' => 'o', 
    		'Ã¸' => 'o', 'Ã¹' => 'u', 'Ãº' => 'u', 'Ã»' => 'u', 'Ã¼' => 'u', 'Å±' => 'u', 'Ã½' => 'y', 'Ã¾' => 'th', 
    		'Ã¿' => 'y',
    		// Latin symbols
    		'Â©' => '(c)',
    		// Greek
    		'Î' => 'A', 'Î' => 'B', 'Î' => 'G', 'Î' => 'D', 'Î' => 'E', 'Î' => 'Z', 'Î' => 'H', 'Î' => '8',
    		'Î' => 'I', 'Î' => 'K', 'Î' => 'L', 'Î' => 'M', 'Î' => 'N', 'Î' => '3', 'Î' => 'O', 'Î ' => 'P',
    		'Î¡' => 'R', 'Î£' => 'S', 'Î¤' => 'T', 'Î¥' => 'Y', 'Î¦' => 'F', 'Î§' => 'X', 'Î¨' => 'PS', 'Î©' => 'W',
    		'Î' => 'A', 'Î' => 'E', 'Î' => 'I', 'Î' => 'O', 'Î' => 'Y', 'Î' => 'H', 'Î' => 'W', 'Îª' => 'I',
    		'Î«' => 'Y',
    		'Î±' => 'a', 'Î²' => 'b', 'Î³' => 'g', 'Î´' => 'd', 'Îµ' => 'e', 'Î¶' => 'z', 'Î·' => 'h', 'Î¸' => '8',
    		'Î¹' => 'i', 'Îº' => 'k', 'Î»' => 'l', 'Î¼' => 'm', 'Î½' => 'n', 'Î¾' => '3', 'Î¿' => 'o', 'Ï' => 'p',
    		'Ï' => 'r', 'Ï' => 's', 'Ï' => 't', 'Ï' => 'y', 'Ï' => 'f', 'Ï' => 'x', 'Ï' => 'ps', 'Ï' => 'w',
    		'Î¬' => 'a', 'Î­' => 'e', 'Î¯' => 'i', 'Ï' => 'o', 'Ï' => 'y', 'Î®' => 'h', 'Ï' => 'w', 'Ï' => 's',
    		'Ï' => 'i', 'Î°' => 'y', 'Ï' => 'y', 'Î' => 'i',
    		// Turkish
    		'Å' => 'S', 'Ä°' => 'I', 'Ã' => 'C', 'Ã' => 'U', 'Ã' => 'O', 'Ä' => 'G',
    		'Å' => 's', 'Ä±' => 'i', 'Ã§' => 'c', 'Ã¼' => 'u', 'Ã¶' => 'o', 'Ä' => 'g', 
    		// Russian
    		'Ð' => 'A', 'Ð' => 'B', 'Ð' => 'V', 'Ð' => 'G', 'Ð' => 'D', 'Ð' => 'E', 'Ð' => 'Yo', 'Ð' => 'Zh',
    		'Ð' => 'Z', 'Ð' => 'I', 'Ð' => 'J', 'Ð' => 'K', 'Ð' => 'L', 'Ð' => 'M', 'Ð' => 'N', 'Ð' => 'O',
    		'Ð' => 'P', 'Ð ' => 'R', 'Ð¡' => 'S', 'Ð¢' => 'T', 'Ð£' => 'U', 'Ð¤' => 'F', 'Ð¥' => 'H', 'Ð¦' => 'C',
    		'Ð§' => 'Ch', 'Ð¨' => 'Sh', 'Ð©' => 'Sh', 'Ðª' => '', 'Ð«' => 'Y', 'Ð¬' => '', 'Ð­' => 'E', 'Ð®' => 'Yu',
    		'Ð¯' => 'Ya',
    		'Ð°' => 'a', 'Ð±' => 'b', 'Ð²' => 'v', 'Ð³' => 'g', 'Ð´' => 'd', 'Ðµ' => 'e', 'Ñ' => 'yo', 'Ð¶' => 'zh',
    		'Ð·' => 'z', 'Ð¸' => 'i', 'Ð¹' => 'j', 'Ðº' => 'k', 'Ð»' => 'l', 'Ð¼' => 'm', 'Ð½' => 'n', 'Ð¾' => 'o',
    		'Ð¿' => 'p', 'Ñ' => 'r', 'Ñ' => 's', 'Ñ' => 't', 'Ñ' => 'u', 'Ñ' => 'f', 'Ñ' => 'h', 'Ñ' => 'c',
    		'Ñ' => 'ch', 'Ñ' => 'sh', 'Ñ' => 'sh', 'Ñ' => '', 'Ñ' => 'y', 'Ñ' => '', 'Ñ' => 'e', 'Ñ' => 'yu',
    		'Ñ' => 'ya',
    		// Ukrainian
    		'Ð' => 'Ye', 'Ð' => 'I', 'Ð' => 'Yi', 'Ò' => 'G',
    		'Ñ' => 'ye', 'Ñ' => 'i', 'Ñ' => 'yi', 'Ò' => 'g',
    		// Czech
    		'Ä' => 'C', 'Ä' => 'D', 'Ä' => 'E', 'Å' => 'N', 'Å' => 'R', 'Å ' => 'S', 'Å¤' => 'T', 'Å®' => 'U', 
    		'Å½' => 'Z', 
    		'Ä' => 'c', 'Ä' => 'd', 'Ä' => 'e', 'Å' => 'n', 'Å' => 'r', 'Å¡' => 's', 'Å¥' => 't', 'Å¯' => 'u',
    		'Å¾' => 'z', 
    		// Polish
    		'Ä' => 'A', 'Ä' => 'C', 'Ä' => 'e', 'Å' => 'L', 'Å' => 'N', 'Ã' => 'o', 'Å' => 'S', 'Å¹' => 'Z', 
    		'Å»' => 'Z', 
    		'Ä' => 'a', 'Ä' => 'c', 'Ä' => 'e', 'Å' => 'l', 'Å' => 'n', 'Ã³' => 'o', 'Å' => 's', 'Åº' => 'z',
    		'Å¼' => 'z',
    		// Latvian
    		'Ä' => 'A', 'Ä' => 'C', 'Ä' => 'E', 'Ä¢' => 'G', 'Äª' => 'i', 'Ä¶' => 'k', 'Ä»' => 'L', 'Å' => 'N', 
    		'Å ' => 'S', 'Åª' => 'u', 'Å½' => 'Z',
    		'Ä' => 'a', 'Ä' => 'c', 'Ä' => 'e', 'Ä£' => 'g', 'Ä«' => 'i', 'Ä·' => 'k', 'Ä¼' => 'l', 'Å' => 'n',
    		'Å¡' => 's', 'Å«' => 'u', 'Å¾' => 'z'
    	);
    	
    	// Make custom replacements
    	//$str = preg_replace(array_keys($options['replacements']), $options['replacements'], $str);
    	
    	// Transliterate characters to ASCII
    	if ($options['transliterate']) {
    		$str = str_replace(array_keys($char_map), $char_map, $str);
    	}
    	
    	// Replace non-alphanumeric characters except space, period, underscore and star
    	$str =preg_replace('/[^ \w_.*]+/', '', $str);
    	
    	$str = trim($str);
    	
    	return $options['uppercase'] ? mb_strtoupper($str, 'UTF-8') : $str;
    }
}